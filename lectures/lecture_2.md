---
math: true
---

# Лекция 2

## Праволинейные грамматики

### Th Класс праволинейных грамматик порождает класс регулярных языков (1)

### Pf 1
>
>Пусть $G = \left(\Sigma, \Gamma, P, S\right)$.
> Построим недетерминированный конечный автомат по грамматике $G$:
>
> $A = \left(\Sigma, \Gamma, \sigma, S, F\right)$, где
>  $$ \sigma: \left(\Gamma \times \Sigma \right) \rightarrow \Gamma \, \, \vert \, \, A \overset{a}{\rightarrow} B  \iff  \left(A \rightarrow aB \right) \in P $$
> $$ F = \left\{A \in \Gamma \, \vert \, \exists \left( A \rightarrow \lambda \right ) \in P \right\} $$

То есть указали правило преобразования грамматики в автомат, причем оно двухстороннее: если есть прямой переход между вершинами $A$ и $B$ по символу $a$, то в грамматике есть правило $\left( A \rightarrow aB \right )$.

## КСЯ и КСГ

### Df $G = \left(\Sigma, \Gamma, P, S\right)$ — **контекстно-свободная грамматика**

> $$ P = \left\{ (A \rightarrow \alpha) \, \vert \, A \in \Gamma, \, \alpha \in \left(\Sigma \cup \Gamma\right)^*\cdot\Gamma\cdot\left(\Sigma\cup \Gamma\right)^*\right\} $$

*Далее $\alpha$ всегда такое — слово над обоими алфавитами и хотя бы одной буквой из нетерминального алфавита.*

### Df Язык $L$ — **контекстно-свободный**

> $$ \exists \, G  - КСГ \, \vert \, L = L(G) $$

### Df Корневое дерево является **упорядоченным**

> *Пусть $child(n, \, T)$ — множество потомков узла $n$ в дереве $T$*
> 
> На его узлах задан линейный порядок $\lessdot$ со свойствами:
> 
> * $X$ — потомок $Y$ $\implies$  $Y\lessdot X$
> * $X$ — сосед $Y$, $Y \lessdot X$ $\implies$ $\forall Z \in child(Y, T): Z \lessdot X$

### Df $T$ — **дерево вывода** слова $w \in \Sigma^*$ в КСГ $G = \left(\Sigma, \Gamma, P, S\right)$

> *Пусть $mark(x) = X$ — функция, показывающая что меткой узла x является $X$*
>
> $T$ — упорядоченное дерево, для которого выполняются условия:
>
> * корень помечен $S$, метки внутренних узлов $m \in \Gamma$, листья $l \in \Sigma\cup\{\lambda\}$, листья с меткой $\lambda$ не имеют соседей.
> * $x$ — узел, $\{y_1,…,y_k\} = child(x)$, $y_1 \lessdot y_2 \lessdot … \lessdot y_k$, $mark(y_i) = Y_i$, $mark(x) = X$ $\implies$ $X \underset{G}{\implies} Y_1\cdot Y_2\cdot …\cdot Y_n$
> * $\{z_i \, \vert \, mark(z_i) = A_i, \, z_i \text{— листья } T \}_{i = 1}^{n} \implies w = A_1\cdot A_2\cdot …\cdot A_n$

### Пример дерева

$$S \rightarrow SS \vert (S) \vert \lambda $$

Язык скобочных последовательностей.

Построим вывод какого-нибудь слова, например $(()())$:
$$S \rightarrow (S) \rightarrow (SS) \rightarrow ((S)S) \rightarrow ((S)(S)) \rightarrow (()(S)) \rightarrow (()()) $$

Это всего лишь один из вариантов вывода.
Построим теперь дерево:

```ascii
           S
           |
    +------+------+
    |      |      |
    (      S      )
           |
    +------+------+
    |             |
    S             S
+---+---+     +---+---+
|   |   |     |   |   |
(   S   )     (   S   )
    |             |
    λ             λ
```

---

### Df $T'$ — **стандартное поддерево** дерева вывода $T$

> *$root(T)$ — так обозначим корень дерева $T$*
>
> *$leafs(T)$ — листья дерева $T$*
>
> * $root(T) = root(T')$
> * $\forall x \in T'$: $x \in leafs(T)$ или $\forall y \in child(x, \, T) \, : \, \, y \in child(x, \, T')$

То есть для построения стандартного поддерева нужно обязательно взять корень основного дерева и для каждого потомка либо объявлять его листом поддерева, либо брать всех его детей и делать для них то же самое.

### Df Вывод $S = \alpha_0 \underset{G}{\implies}  \alpha_1 \underset{G}{\implies} … \underset{G}{\implies} \alpha_n = w$ слова $w$ **представим деревом вывода $T$** в грамматике $G$

> *$word(T)$ — слово, полученное обходом листьев дерева $T$ слева направо*
>
> $\exists T_0, T_1, …, T_k$ — стандартные поддеревья $T$, такие что:
> 
> * $word(T_i) = \alpha_i$ ($\alpha_i$ назовем $i$-той формой)
> * $T_0 \subset T_1 \subset … \subset T_n$

### Df Грамматика $G$ — **однозначная**

> *$tree(w)$ — множество деревьев вывода для данного слова*
>
> $\forall w \in L(G) : \, \, \vert tree(w) \vert \, = 1$ 

### Пример разных деревьев вывода 

Простая грамматика для арифметических выражений:
$$ E \implies E + E \, \vert \,E \times E \, \vert \, (E) \,\vert \, x $$
Здесь $x$ — токен-плейсхолдер, для грамматики неважно, какое конкретно там число стояло.

Для слова  $"x + x\cdot x"$ можно построить дерево вывода такое:

```ascii
         E
         |
         |
+--------+---------+
|        |         |
|        |         |
v        |         |
E        +         |
|             +----E---+
|             |    |   |
|             |    |   |
|             |    ×   |
λ             E        E
              |        |
              |        |
              λ        λ
````

или такое:

```ascii
               E
               |
               |
      +--------+---------+
      |        |         |
      |        |         |
      |        |         |
      |        +         |
 +----E---+              E
 |    |   |              |
 |    |   |              |
 |    ×   |              |
 E        E              λ
 |        |
 |        |
 λ        λ
```

Деревья вывода разные, хотя всего лишь отражены вертикально, так как меняется порядок обхода.

Но мы можем построить грамматику, которая порождает тот же язык, но уже не позволит построить разные деревья:

$$E \rightarrow E + T | T $$

$$T \rightarrow T \times F | F $$

$$F \rightarrow (E) | x $$

Мы воспользовались идеей, что выражение есть сумма произведений.

---

### Df КС язык $L$ **однозначный**

> $\exists G: G \text{ — однозначная} \, : \, L(G) = L$

### Df Вывод слова $w$ **левосторонний**

> каждая следующая форма в выводе получена из предыдущей применением правила вывода к самому левому нетерминалу в форме.


### Df Вывод слова $w$ **правосторонний**

> каждая следующая форма в выводе получена из предыдущей применением правила вывода к самому правому нетерминалу в форме.

